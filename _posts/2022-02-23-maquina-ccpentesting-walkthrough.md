---
layout: single
title: Máquina CC Pen Testing - TryHackMe (OSCP Style)
excerpt: "CC: Pen Testing es un room de TryHackMe que te permite adquirir ciertos conocimientos básicos sobre el procedimiento del pentesting en una máquina. Vamos a resolver la máquina que viene al final del room a modo de examen final, la cual es bastante sencilla."
date: 2022-02-23
classes: wide
header:
  teaser: /assets/images/ccpentesting/portada.png
  teaser_home_page: true
categories:
  - THM
  - Blog
  - Writeup
tags:
  - Fuzzing
  - Cracking
  - SSH
  - Sudo
  - Su
---

# Introducción
[CC: Pen Testing](https://tryhackme.com/room/ccpentesting) es un room de TryHackMe que te permite adquirir ciertos conocimientos básicos sobre el procedimiento del pentesting en una máquina, desde escaneo de puertos, pasando por crackeo de contraseñas hasta privilege escalation. Es muy básica, y recomiendo hacerla al completo si deseas aprender un poco más.

En este caso, solo me limitaré a realizar la máquina que viene al final del room a modo de examen final, la cual es bastante sencilla y es recomendable para la siguiente máquina del path Offensive Pentesting que estamos siguiendo.

# Reconocimiento
La máquina tiene un sistema operativo Linux, lo cual podemos observar por medio de una traza ICMP.

![1]

Por medio de un escaneo de puertos con nmap, detectamos aquellos que se encuentren activos con un estatus **open** en la máquina víctima:

	nmap -sS --min-rate 5000 -p- --open -Pn -n 10.10.59.139 -oG allPorts

![2]

Vemos que se encuentran habilitados únicamente el puerto 22 y el 80.

Si realizamos un escaneo más exhaustivo en busca de servicios y versiones específicas de dichos puertos, nos encontramos con la siguiente información:

	nmap -sC -sV -p22,80 10.10.59.139 -oN targeted

![3]

No encontramos información relevante, así que vamos a investigar más a fondo primero el sitio web.

# Servicio HTTP
Al abrir la página en un navegador, nos encontramos con una página por defecto de Apache, por lo que suponemos que en el directorio raíz no hay un sitio web. El código fuente tampoco nos da algún indicio.

![4]

Cuando nos encontramos en un callejón como este, sin más puertos ni servicios que analizar, debemos recurrir a un fuzzing del sitio web en busca de directorios. Para ello, nos auciliamos de **wfuzz**:

    wfuzz -c --hc=404 -t 50 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt http://10.10.59.139/FUZZ

![5]

Esto nos devuelve un directorio llamado **secret**, y si accedemos a este por medio del navegador, veremos que no hay nada (el código fuente también está vacío). Esto puede significar dos cosas: o bien se trata de un rabbit hole donde no hay más información al respecto, o bien, se trata de un directorio litereal (hasta este punto hemos usado insiscriminadamente la palabra directorio para referirnos a esto, pero en sí se trata de sitios web internos; en este caso, literalmente es una carpeta, espero se logre entender lo que trato de decir).

![6]

Al tratarse de una carpeta, entonces esto quiere decir que dentro debe haber archivos, y estos archivos deben de tener una extensión. Por lo tanto, el siguiente paso debe ser volver a realizar un fuzzing, pero ahora en busca de archivos con extensiones que supongamos sean válidas.

Para ello, creamos primero un mini diccionario con algunas extensiones que supongamos pueden encontrarse en el directorio web:

    sh
    txt
    php
    html

Una vez tengamos este diccionario, entonces empleamos los dos en wfuzz de la siguiente manera:

    wfuzz -c --hc=404 -t 50 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -w extensiones http://10.10.59.139/secret/FUZZ.FUZ2Z

Con esto, le indicamos a wfuzz que vamos a emplear dos diccionarios y el órden en el que irán en la consulta.

![7]

Vemos que la consulta nos devuelve un archivo de interés llamado **secret.txt**, y si accedemos a él, veremos lo siguiente:

![8]

Al parecer se trata de credenciales, por lo que pasamos la parte correspondiente a la contraseña por Crackstation, obteniendo la contraseña en texto claro:

![9]

    nyan:nyan

# Acceso por SSH
Dado que el único servicio que nos queda para probar las credenciales es SSH, las introducimos, observando que estás son válidas y entonces hemos ganado acceso al sistema:

![10]

# Privilege Escalation
Solo nos queda la escalada de privilegios, y como de consumbre, la suerte está de nuestro lado, ya que en nuestra primera consulta a los permisos sudo nos encontramos con la misconfiguration por excelencia: **su** tiene permisos sudo sin necesidad de proporcionar contraseña:

![11]

Nota: En la imagen se aprecia también la flag de usuario.

Este binario nos permite cambiar de nuestro usuario a un usuario privilegiado, siempre que proporcionemos la contraseña respectiva. Como en este caso no nos la va a solicitar, solo deberemos introducir:

    sudo su

Y el sistema inmediatamente nos moverá a una bash perteneciente al usuario root. Listo, esta vulnerabilidad es una mala configuración de seguridad, y una bastante poco común pero que hay que tener en cuenta. Solo nos resta ver la flag de root para finalizar la máquina.

![12]

[1]:/assets/images/ccpentesting/1.png
[2]:/assets/images/ccpentesting/2.png
[3]:/assets/images/ccpentesting/3.png
[4]:/assets/images/ccpentesting/4.png
[5]:/assets/images/ccpentesting/5.png
[6]:/assets/images/ccpentesting/6.png
[7]:/assets/images/ccpentesting/7.png
[8]:/assets/images/ccpentesting/8.png
[9]:/assets/images/ccpentesting/9.png
[10]:/assets/images/ccpentesting/10.png
[11]:/assets/images/ccpentesting/11.png
[12]:/assets/images/ccpentesting/12.png